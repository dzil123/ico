[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode unshaded;

uniform float percent_visible : hint_range(0.0, 1.0, 0.01) = 0.1;
uniform vec4 outer_color: hint_color = vec4(vec3(0.4), 1.0);
uniform vec4 inner_color: hint_color = vec4(vec3(0.2), 1.0);
uniform bool toggle_outer = false;
uniform vec3 highlight_tri_pos;

varying flat vec3 tri_pos;

vec3 pick_tri(vec2 pos) {
	return vec3(
		ceil(1.0 * pos.x - sqrt(3.0) / 3.0 * pos.y),
		floor(sqrt(3.0) * 2.0 / 3.0 * pos.y) + 1.0,
		ceil(-1.0 * pos.x - sqrt(3.0) / 3.0 * pos.y)
	);
}

void vertex() {
	mat4 mat = WORLD_MATRIX;
	vec2 world_pos = vec2(mat[3][0], mat[3][2]); // model world position
	tri_pos = pick_tri(world_pos * vec2(1, -1) - 0.25);
//	UV2 = vec2(mat[0][2], 0); // 0 if pointy, 1 if flat
}

void fragment() {
	vec3 bary = COLOR.xyz;  // triangle barycentric coordinates
	
	float p = percent_visible;
	// rescale 0-1 to edge-center - the center coordinate is vec3(1/3)
	p /= 3.0;
	
	vec3 k = fwidth(bary) / 2.0; // 2 is optimal because p-k,p+k
	
	vec3 edge_split = smoothstep(p-k, p+k, bary);
	float edge = edge_split.x * edge_split.y * edge_split.z;
	
	if (toggle_outer) {
		edge = 1.0 - edge;
	}
	
	vec3 color = mix(outer_color, inner_color, edge).rgb;
	
	if (distance(tri_pos, highlight_tri_pos) < 0.1) {
		color = vec3(1, 0, 0);
	}
	
	ALBEDO = color;
}
"

[resource]
shader = SubResource( 1 )
shader_param/percent_visible = 0.15
shader_param/outer_color = Color( 0.51, 0.51, 0.51, 1 )
shader_param/inner_color = Color( 0.239216, 0.239216, 0.239216, 1 )
shader_param/toggle_outer = false
shader_param/highlight_tri_pos = Vector3( 0, 4, -3 )
